# Linked Stack

Linked list를 활용해 스택 구현. overflow 걱정할 필요 없다.

## 1. Struct

- StackNode : 데이터와 다음 노드를 가리키는 포인터 존재
- LinkedStack : 현재 원소 개수와 Top을 가리키는 포인터 존재
    + 즉 스택의 포인터가 가리키는 원소가 탑이고
    + 포인터를 따라가면 먼저 push된 원소들이 차례로 연결되는 것

## 2. Abstract Data Type

### 2.1 Create

- Array 기반 스택과 비슷하지만 입력값은 없다.
- 먼저 스택 사이즈의 메모리를 할당해서 스택을 만들고, 모든 비트의 값을 0으로 만든다. 자동으로 top을 가리키는 포인터에 NULL 값이 들어감

### 2.2 Push

- 스택 포인터와 노드를 입력으로 받는다.
- 새로 노드 사이즈의 메모리를 할당해서 입력으로 받은 노드를 복사한다.
- 링크 정리
    + 새로운 노드가 기존 top 노드를 가리키도록 하고
    + 스택 내부의 헤더 포인터가 새로운 노드를 가리키도록 한다.
- 현재 원소개수 ++

### 2.3 Pop

- 비어있는지 먼저 확인하고 안 비어있을 때만 작업 수행
- 링크 정리
    + top의 원소를 따로 변수로 만들어서 가리키도록 함
    + 기존 top 원소가 가리키던 위에서 두 번째 원소를 스택의 헤더 포인터가 가리키도록 한다.
    + 기존 top 원소의 포인터는 NULL을 가리키도록 함
- 원소 개수 --
- Array stack과 마찬가지로 pop을 통해 받은 값을 쓴 후에는 free 해줘야 한다.

### 2.4 Peek

- 비어있는지 확인
- 스택의 헤더 포인터가 가리키는 top 원소를 리턴
- Peek을 통해 받은 값은 free 하면 안됨

### 2.5 Delete

- 역시 먼저 원소들을 모두 free하고, 그 다음 스택을 free한다.
- 두 개의 노드 포인터를 선언한다.
    + 하나는 순회에 사용하는 포인터
    + 하나는 지울 때 사용하는 포인터
- 순회를 하면서 다음 포인터로 넘어가면 마지막 노드가 NULL을 가리키고 있으므로 조건을 포인터로 주면 마지막에서 멈추게 된다.
- 반복을 돌려서 그 때 그 때의 원소를 지울 포인터에 복사하고 free를 해주게되면 모든 원소를 지울 수 있다.
- 반복이 끝나면 스택 free

### 2.6 Size functions

- isLinkedStackFull : 꽉 찼는지 여부를 리턴. 하지만 Linked stack에선 꽉 차는 상황이 없으므로 무조건 FALSE 리턴
- isLinkedStackEmpty : 비었는지 여부 리턴. 현재 원소 개수가 0이면 TRUE 리턴한다.
