# Reverse & Parenthesis

## 1. Reverse string

- 방식
    + 문자열을 역순으로 만드는 것을 스택으로 푸는 문제
    + 이 경우엔 문자열 길이가 정해져있기 때문에 딱히 스택으로 풀지 않아도 인덱스를 역순으로 거슬러올라가면서 새로운 문자열을 만들면 된다.
    + 하지만 연습삼아 linked stack으로 풀었고 각 문자를 스택에 다 넣고, 그 후에 모두 빼는 형태로 구현했다.
- 필요한 변수
    + 스택 포인터
    + 노드 : push는 input으로 받는 구조체 노드를 복사하는 형태로 구현되어있다. 그래서 이 때는 node.data의 값만 계속 바꿔줘서 재활용하면 된다. 이 때 사용할 노드
    + 노드 포인터 : pop할 때 스택에 속한 노드를 복사하는 것이 아니라 주소값을 리턴한다. 그 주소값을 받을 변수이고, 나중에 꼭 free해줘야함
    + 리턴할 문자열 포인터, 루프를 돌 때 사용하는 i, 문자열 길이를 저장할 size
- 순서
    + 매개변수로 받는 문자열 포인터가 NULL인지, 길이는 0보다 큰지 체크
    + 리턴할 문자열을 size + 1만큼 메모리 할당. 문자열이라 마지막에 `'\0'`을 넣기 때문에 1바이트 더 할당하는 것
    + 스택 생성
    + 문자열의 각 문자를 순서대로 스택에 삽입. 이 때 노드 변수를 반복문에서 재사용한다.
    + 스택에서 다시 모두 뺀다. 이 때는 pop을 사용하는데 이미 할당된 메모리에 존재하는 노드이기 때문에 포인터 변수를 활용한다. 리턴할 문자열에 해당 데이터의 값을 하나하나 넣고 사용한 후엔 free 한다.
    + 마지막에 스택은 다 썼으니 삭제하고 문자열을 가리키는 포인터 리턴

## 2. Check parenthesis

- 방식
    + 문자열에서 한 문자씩 반복을 돌린다.
    + 여는 괄호를 만나면 스택에 push한다.
    + 닫는 괄호를 만나면 스택에서 pop해서 매칭되는지 살핀다. 매칭되면 반복을 계속하고, 매칭이 안되면 반복문 탈출해서 FALSE를 리턴한다.
    + 모든 반복을 다 돌았을 때 스택이 깨끗하면 TRUE, 괄호가 모두 빠지지 않았으면 FALSE 리턴
- 특이한 점은 return할 boolean 변수를 따로 뒀다는 것이다. 다른 언어와 달리 함수를 끝내기 전에 스택과 노드들을 free해줘야하기 때문에 리턴값을 변경해가면서 진행한다.
- 순서
    + 문자열 체크: NULL인지 길이가 0인지
    + 스택을 만든다.
    + 입력받은 문자열에서 문자 하나하나를 반복을 돈다. 기본적인 반복조건(길이)에 리턴값도 추가한다. 만약 반복 중간에 틀린 쌍이 나오면 바로 반복을 벗어나서 FALSE를 리턴해야하기 때문이다.
    + 여는 괄호가 나오면 재활용할 노드에 데이터를 해당 문자로 넣고 push
    + 닫는 괄호가 나오면 먼저 pop하고, 매칭이 되면 그냥 free, 매칭이 안되면 free하면서 리턴값을 FALSE로 바꾸고 break한다.
    + for 반복을 끝났을 때 만약 비어있지 않다면 리턴값을 FALSE로 바꾼다.
    + 스택을 free하고 마지막에 리턴값을 리턴한다.
