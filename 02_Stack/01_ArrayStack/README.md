# Array stack

## 1. Stack 기본

- LIFO(Last In First Out) 특성의 선형 자료구조
- 항아리 형태라 생각하면 되고, 데이터를 넣으면 일렬로 위로 쌓이는 원리. 그래서 뺄 때는 맨 위의 값만 뺄 수 있음
- 원소를 넣고, 빼고, 체크하고는 간결한 구조
- 용어
    + overflow : 스택이 꽉 찼는데 원소 추가할 때 발생
    + underflow : 스택이 비었는데 원소를 pop 할 때 발생
    + top : 가장 최근에 삽입된 원소를 가리킴. 스택의 가장 위 부분.
- 주요 사용 상황: `의존`으로 인한 `상태 저장`
    + 상태를 저장할 때 유용. 태스크 간 의존이 있을 때 상태를 저장해두고 그 지점에서 다시 하던 작업을 계속할 수 있다.
    + 즉 A를 마치기 위해 B를 먼저 마무리해야할 때 사용하는데 재귀호출 형태에서 자주 보인다.
- 사용 현실 예시
    + 미역국 끓여야지 -> 빈 스택에 처음으로 원소 push
    + 마트를 가야겠군 -> 스택에 마트 추가(미역국 위에 얹혀짐)
    + 가다가 세탁소 들러야겠다 -> 스택에 세탁소 추가(마트 위에 세탁소 얹혀짐)되지만 세탁소 들르는 순간 바로 모든게 해결되며 pop
    + 마트에서 미역, 국간장, 후추는 샀는데 돈이 부족해서 고기, 냄비를 못 삼 -> 마트(고기,냄비)를 스택에 push
    + 집에 가야겠군 -> 집에가서 카드 가져오는거 스택에 push
    + 집에 갔는데 열쇠를 세탁소에 놔두고 온 것을 깨달음 -> 세탁소에 들러서 열쇠를 받으면 바로 해결되면서 스택에 세탁소 올라갔다가 바로 빠짐
    + 남은 스택들이 모두 연달아 해결되면서 pop 된다. 집 가서 열쇠로 열고 카드 겟하고 마트가서 계산하고, 다시 집 와서 미역국 끓임.

## 2. Abstract Data Type

### 2.1 Struct

- ArrayStackNode : 데이터 단위
- ArrayStack : 전체 크기, 현재 원소 개수, 데이터가 들어가는 배열을 갖는다.

### 2.2 Create

- 최대 원소 개수를 인풋으로 받는다.
- ArrayStack을 먼저 malloc으로 할당하고, 인풋으로 받은 값을 바탕으로 배열을 내부에 다시 할당한다.
- 항상 원소 개수가 양수인지, malloc의 리턴값은 정확한지 등을 체크

### 2.3 Push

- 스택과 넣을 노드를 입력으로 받는다.
- 먼저 스택이 꽉 찼는지 검사하고 비어있을 때만 삽입한다.
- 원소 삽입은 배열에 값을 할당하는 것과 같고, 삽입 후엔 현재 원소 개수를 1 증가, 리턴값을 TRUE로 바꿔준다.
- 리턴값은 성공 또는 실패에 따른 1, 0 값이다.

### 2.4 Pop

- 스택을 입력으로 받는다.
- 스택이 비었는지 검사하고 비지 않았을 때만 작업 수행
- 마지막 원소 작업
    + 리턴 : 노드 사이즈의 메모리를 할당하고, 이를 가리키는 노드의 포인터 변수에 스택의 마지막 원소를 복사한다. 함수 마지막에서 리턴할 값이다.
    + 제거 : 직접적으로 삭제하는 것이 아니라 현재 원소 개수를 하나 줄이면서 Top 인덱스를 바꾸는 것.

### 2.5 Peek

- Pop과 똑같고, 다만 현재원소개수 조작이 없을 뿐

### 2.6 Size function

- isArrayStackFull : 최대원소수와 현재원소수가 같으면 TRUE
- isEmpty : 현재 원소 수가 0이면 TRUE

### 2.7 Delete

- 먼저 Stack 내의 배열부터 free 하고
- 이후에 Stack을 free 한다.
